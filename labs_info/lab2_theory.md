# ЛР №2: D-алгоритм (метод активизации многомерного пути)

## Введение

D-алгоритм (алгоритм Рота) — это систематический метод автоматической генерации тестов для комбинационных схем, который **гарантированно находит тест, если он существует**. Метод использует кубическое представление и работает с многомерными путями пропагации неисправностей.

## Основные понятия

### Кубическое представление

Вместо классических значений {0, 1} используется расширенный алфавит:

- **0** — логический ноль
- **1** — логическая единица
- **x** — безразличное значение (don't care)
- **d** — переход 0→1 (в исправной схеме 0, в неисправной 1)
- **D** — переход 1→0 (в исправной схеме 1, в неисправной 0)

Символы **d** и **D** описывают распространение неисправности через схему.

### Типы кубов

#### 1. Сингулярные кубы
Описывают нормальное поведение элемента без неисправностей.

**Пример для элемента 2-OR**:
```
x1  x2  | out
--------+----
1   x   | 1     (если хотя бы один вход = 1)
x   1   | 1
0   0   | 0     (только если оба входа = 0)
```

#### 2. D-кубы элемента
Описывают пропагацию изменения (d/D) через элемент.

**Пример для элемента AND**:
```
x1  x2  | out
--------+----
d   1   | d     (изменение на входе 1 пропагируется)
1   d   | d     (изменение на входе 2 пропагируется)
```

#### 3. Примитивные D-кубы неисправности
Описывают активацию неисправности на конкретном полюсе.

**Пример для AND с неисправностью SA0 на выходе**:
```
x1  x2  | out
--------+----
1   1   | D     (нормально 1, с дефектом 0)
```

## Алгоритм D-алгоритма

### Фаза 1: Выбор примитивного D-куба неисправности

Для заданной неисправности (например, F3/0) выбирается примитивный D-куб, который **активирует** эту неисправность.

### Фаза 2: D-проход (D-drive)

Цель: распространить символ d или D от места неисправности к **хотя бы одному** выходу схемы.

**Процедура**:
1. Найти элемент, на входе которого есть d или D
2. Выбрать D-куб этого элемента
3. Выполнить D-пересечение текущего куба с D-кубом элемента
4. Повторять, пока d/D не дойдёт до выхода

### Фаза 3: Консистентность (обратный ход)

Цель: назначить определённые значения всем **оставшимся** переменным (заменить x на 0 или 1).

**Процедура**:
1. Для элементов без d/D на выходе использовать сингулярные кубы
2. Выполнить пересечение с текущим кубом
3. Проверить консистентность (отсутствие противоречий)
4. Если остались x на входах, подобрать значения методом проб

## D-пересечение

Операция объединения двух кубов с проверкой совместимости:

```
  0 ∩ 0 = 0      0 ∩ x = 0      d ∩ d = d
  1 ∩ 1 = 1      1 ∩ x = 1      D ∩ D = D
  x ∩ x = x      d ∩ 1 = d      d ∩ D = ∅ (конфликт!)
  0 ∩ 1 = ∅      D ∩ 0 = D      d ∩ 0 = ∅ (конфликт!)
```

Если результат пересечения — ∅ (пустое множество), кубы несовместимы.

## Пример работы алгоритма

Для схемы:
```
F1 = NAND(x1, x2)
F5 = OR(F1, F4)
```

Неисправность: **x1/0** (stuck-at-0 на входе x1)

### Шаг 1: Примитивный D-куб

Для входной неисправности x1/0 нужно установить x1=1, чтобы активировать дефект:
```
x1=1, x2=x → F1 зависит от x1
```

### Шаг 2: D-проход через F1 (NAND)

```
x1  x2  | F1
--------+----
D   1   | d    (NAND инвертирует: 1→0 становится 0→1)
```

После пересечения: x1=1, x2=1, F1=d

### Шаг 3: D-проход через F5 (OR)

Для пропагации d через OR нужен второй вход F4=0:
```
F1  F4  | F5
--------+----
d   0   | d
```

После пересечения: F5=d (неисправность дошла до выхода!)

### Шаг 4: Консистентность

Нужно определить входы, дающие F4=0. Используем сингулярные кубы для элементов, формирующих F4.

**Результат**: тест `110...` обнаруживает неисправность x1/0.

## Сложность метода

- **Временная сложность**: экспоненциальная в худшем случае, но на практике полиномиальная для большинства схем
- **Покрытие**: гарантирует нахождение теста, если он существует
- **Размер тестового множества**: обычно меньше, чем у метода одномерного пути

## Преимущества

✅ Гарантия нахождения теста (если он существует)  
✅ Компактное тестовое множество  
✅ Один тест может покрывать несколько неисправностей  
✅ Автоматизация процесса (не требует выбора пути вручную)  
✅ Учёт многомерных путей пропагации

## Недостатки

❌ Сложность реализации  
❌ Не гарантирует минимальное множество тестов  
❌ Может не найти тест для некоторых сложных неисправностей (требуется расширение метода)  
❌ Вычислительная сложность для больших схем

## Расширения D-алгоритма

### PODEM (Path-Oriented Decision Making)
- Более эффективный поиск
- Использует эвристики для выбора переменных
- Меньше вариантов перебора

### FAN (Fanout-Oriented Algorithm)
- Оптимизация для схем с большим числом разветвлений
- Учёт топологии схемы

### ATPG (Automatic Test Pattern Generation)
- Промышленные инструменты на базе D-алгоритма
- Обработка миллионов вентилей

## Сравнение с ЛР1

| Характеристика | ЛР1 (одномерный путь) | ЛР2 (D-алгоритм) |
|---|---|---|
| Выбор пути | Вручную, один путь | Автоматически, все пути |
| Число тестов | Больше (по тесту на неисправность) | Меньше (один тест на несколько) |
| Сложность | Простой, понятный | Сложный, требует кубов |
| Гарантии | 100% для простых схем | Гарантия нахождения теста |
| Автоматизация | Частичная | Полная |

## Применение

D-алгоритм используется:
- В промышленных САПР для автоматической генерации тестов
- Для сложных схем с миллионами элементов (с оптимизациями)
- В встроенном самотестировании (BIST)
- Как теоретическая основа современных ATPG-инструментов

## Связь с другими методами

- **ЛР1** — упрощённая версия без кубов
- **ЛР3 (LFSR)** — использует найденные тесты для оптимизации случайного тестирования
- **Современные ATPG** — используют идеи D-алгоритма + эвристики + параллелизм

