# ЛР №4: Тестирование ОЗУ — классические неисправности

## Введение

Оперативная память (ОЗУ/RAM) — один из ключевых компонентов вычислительных систем. Из-за высокой плотности упаковки и сложности структуры памяти возникают специфические неисправности, отличные от логических схем. Для тестирования памяти разработаны специальные алгоритмы.

## Архитектура ОЗУ

### Функциональная модель

```
        ┌─────────────────────────────┐
Адрес ─►│ Дешифратор адреса          │
        ├─────────────────────────────┤
        │  Массив ячеек памяти        │
        │  (Memory Cell Array)        │
        ├─────────────────────────────┤
Данные◄►│ Усилитель чтения/записи     │
        ├─────────────────────────────┤
R/W ───►│ Логика управления           │
        └─────────────────────────────┘
```

**Компоненты**:
- **Дешифратор адреса** — выбор строки и столбца
- **Массив ячеек** — хранение данных (статические или динамические)
- **Усилители считывания** — детектирование слабого сигнала
- **Драйверы записи** — установка значения в ячейке

## Классификация неисправностей

### 1. Неисправности схем обрамления

#### Адресные неисправности (AF — Address Faults)

**Типы**:
- **Ни одна ячейка не доступна** по заданному адресу
- **Заданная ячейка недоступна** (все адреса пропускают её)
- **Доступ сразу к нескольким ячейкам** по одному адресу
- **Одна ячейка доступна по нескольким адресам**

**Пример**: Застрявший бит адресной шины (A₃ stuck-at-1):
```
Адрес 0b0000 → читается ячейка 0b1000
Адрес 0b0100 → читается ячейка 0b1100
```

### 2. Неисправности массива ячеек

#### Константные неисправности (SAF — Stuck-At Faults)

**SAF0**: Ячейка всегда хранит 0, независимо от записанного значения  
**SAF1**: Ячейка всегда хранит 1, независимо от записанного значения

**Причины**: Дефект в триггере, короткое замыкание линий питания/земли.

#### Переходные неисправности (TF — Transition Faults)

**TF ↑**: Невозможен переход 0→1 (ячейка застревает в 0)  
**TF ↓**: Невозможен переход 1→0 (ячейка застревает в 1)

**Причина**: Слабые транзисторы записи, плохая связь с битовыми линиями.

### 3. Неисправности взаимного влияния

#### Инверсные неисправности (CFin — Inversion Coupling Faults)

При переходе в **агрессоре** (attacking cell) происходит **инверсия** в **жертве** (victim cell).

**Обозначение**: `<↑;↓>` — переход ↑ в агрессоре инвертирует жертву

**Пример**:
```
Ячейка A₁₀ (агрессор): 0→1
Ячейка A₂₅ (жертва):   1→0 (инвертировалась!)
```

**Причины**: Ёмкостная связь между битовыми линиями, перекрёстные наводки.

#### Неисправности прямого действия (CFid — Idempotent Coupling Faults)

При переходе в агрессоре жертва **принудительно устанавливается** в 0 или 1.

**Обозначение**: `<↑;1>` — переход ↑ в агрессоре устанавливает жертву в 1

**Пример**:
```
Ячейка A₅ (агрессор): 0→1
Ячейка A₂₀ (жертва):  x→0 (установлена в 0)
```

**Причины**: Паразитные резистивные связи, общие линии питания.

## Маршевые тесты

### Концепция маршевого теста

**Маршевый тест** — последовательность **маршевых элементов**, каждый из которых применяется ко **всем** ячейкам памяти.

**Маршевый элемент**: `⇕(операции)`

**Обозначения**:
- **⇑** — адреса возрастают (0, 1, 2, ..., N-1)
- **⇓** — адреса убывают (N-1, ..., 2, 1, 0)
- **⇕** — направление не важно

**Операции**:
- **w0** — записать 0
- **w1** — записать 1
- **r0** — прочитать и ожидать 0
- **r1** — прочитать и ожидать 1

### Примеры маршевых тестов

#### MATS (Simple)
```
⇕(w0); ⇑(r0, w1); ⇓(r1)
```

**Действия**:
1. Записать 0 во все ячейки
2. Возрастающий адрес: читать 0, писать 1
3. Убывающий адрес: читать 1

**Сложность**: 4N  
**Покрытие**: AF, SAF

#### MATS+ (Extended)
```
⇕(w0); ⇑(r0, w1); ⇓(r1, w0)
```

**Добавлено**: Финальная запись 0 (обратная инициализация)

**Сложность**: 5N  
**Покрытие**: AF, SAF

#### MATS++ (Extended Extended)
```
⇕(w0); ⇑(r0, w1); ⇓(r1, w0, r0)
```

**Добавлено**: Финальное чтение 0 (проверка записи)

**Сложность**: 6N  
**Покрытие**: AF, SAF, некоторые CFin

#### March C (Comprehensive)
```
⇕(w0); ⇑(r0,w1); ⇑(r1,w0); ⇓(r0,w1); ⇓(r1,w0); ⇕(r0)
```

**Сложность**: 11N  
**Покрытие**: AF, SAF, TF, CFin (частично)

### Walking 0/1 (Галопирующие биты)

**Идея**: Одна ячейка содержит уникальное значение, остальные — противоположное.

**Алгоритм Walking 1**:
```
Для каждой ячейки i:
    Записать 0 во все ячейки, кроме i
    Записать 1 в ячейку i
    Прочитать все ячейки и проверить
    Прочитать ячейку i и проверить
```

**Сложность**: O(N²)  
**Покрытие**: AF, SAF, CFin, CFid (высокое)

**Проблема**: Квадратичная сложность — неприемлемо для больших памятей.

## Анализ покрытия

### Сравнение тестов

| Тест | Сложность | AF | SAF | TF | CFin | CFid |
|---|---|---|---|---|---|---|
| MATS | 4N | ✓ | ✓ | — | — | — |
| MATS+ | 5N | ✓ | ✓ | — | — | — |
| MATS++ | 6N | ✓ | ✓ | — | ✓* | ✓* |
| March C | 11N | ✓ | ✓ | ✓ | ✓* | — |
| Walking 0/1 | N² | ✓ | ✓ | ✓ | ✓ | ✓* |
| GALPAT | 2N² | ✓ | ✓ | ✓ | ✓ | ✓ |

✓ — полное покрытие, ✓* — частичное покрытие

### Практические рекомендации

**Для малых памятей (< 1 Мбит)**:
- Walking 0/1 или GALPAT (если время не критично)
- Максимальное покрытие

**Для средних памятей (1-16 Мбит)**:
- March C или March C-
- Баланс покрытия и времени

**Для больших памятей (> 16 Мбит)**:
- MATS++ или March X
- Быстрое тестирование с базовым покрытием

## Временная сложность

Для памяти **N = 1 Мбит** (1,048,576 бит) с циклом 10 нс:

| Тест | Операций | Время |
|---|---|---|
| MATS++ (6N) | 6,291,456 | ~63 мс |
| March C (11N) | 11,534,336 | ~115 мс |
| Walking 0/1 (N²) | 1.1×10¹² | ~3 часа |

**Вывод**: Маршевые тесты O(N) практичны, O(N²) — только для малых объёмов.

## Причины неисправностей

### Производственные дефекты
- Дефекты фотолитографии (пропущенные/лишние слои)
- Загрязнение подложки
- Дефекты металлизации (обрывы, КЗ)

### Эксплуатационные
- Деградация оксида (пробой изоляции)
- Горячие электроны (повреждение транзисторов)
- Электромиграция (перемещение атомов металла)
- Альфа-частицы (космическое излучение для DRAM)

### Электрические
- Перенапряжение
- Электростатический разряд (ESD)
- Нарушение режимов питания

## Тестирование на производстве

### Этапы тестирования

1. **Wafer-level testing** (на пластине)
   - Быстрые тесты (MATS+)
   - Отбраковка явных дефектов

2. **Package-level testing** (в корпусе)
   - Полные тесты (March C, GALPAT)
   - Температурные режимы
   - Классификация по скорости

3. **System-level testing** (в системе)
   - POST (Power-On Self-Test)
   - Периодическая диагностика
   - Обнаружение деградации

### Встроенное самотестирование (MBIST)

**Memory BIST** — аппаратный модуль для автономного тестирования:

```
┌─────────┐
│ FSM     │ ──► Генерация адресов
│(контр-р)│ ──► Генерация данных
└────┬────┘ ──► Проверка откликов
     ↓
┌─────────┐
│ Memory  │
└─────────┘
```

**Преимущества**:
- Не требует внешнего тестера
- Работает на полной скорости памяти
- Малые затраты площади (~2-5% от памяти)

## Особенности SRAM vs DRAM

### SRAM (Static RAM)

**Структура**: 6 транзисторов на ячейку  
**Неисправности**: Преимущественно SAF, CFin  
**Тесты**: March C, March X достаточны

### DRAM (Dynamic RAM)

**Структура**: 1 транзистор + конденсатор  
**Неисправности**: + утечка заряда, refresh-ошибки  
**Тесты**: + тесты регенерации, паттерн-чувствительные тесты

## Связь с другими лабораторными

- **ЛР1, ЛР2** — методы для логических схем (включая дешифраторы памяти)
- **ЛР3 (LFSR)** — может использоваться в MBIST для генерации адресов
- **ЛР5** — расширение на кодочувствительные неисправности (NPSF)

## Выводы

✅ Маршевые тесты O(N) — стандарт для промышленного тестирования  
✅ MATS++ обеспечивает базовое покрытие за минимальное время  
✅ March C — оптимальный баланс для большинства применений  
✅ Walking 0/1 — только для малых памятей или критичных систем  
✅ MBIST — необходим для современных SoC с встроенной памятью

